# 撮合算法模型

在了解撮合的算法之前，我们首先应该了解一些业务上的概念：

* 下单：用一种coin去兑换另外一种coin的订单数据；
* 撤单：取消挂在盘口中的订单；
* 交易对：我们称之为symbol，即相互兑换的两个币种，大多symbol还是以U本位为主，如BTCUSDT、ETHUSDT等；
* 订单薄：存储未完成的限价单；
* 盘口：对订单薄的归集，主要归集相同价格下，订单的交易数量；
* 市价单：以市场价进行交易，订单不会进入盘口；
* 限价单：以指定的价格进行交易，未完成则进行盘口；
* take单：指的是用户新建的订单，发起订单以后，意味着这条数据将会去盘口数据进行撮合，也称先手单；
* mark单：它是于take单对应的，盘口中的数据都是mark单，是未完成的限价单的集合，也称为挂单；
* 方向：买入还是卖出；
* 档位：不同order的相同出价，在盘口中体现。
* 全部成交：订单完全成交；
* 部分成交：订单只成交一部分；

其次，我们在做撮合算法的时候，需要遵循撮合的基本规则：

* 价格优先：优先与满足条件的最优对手单进行成交，成交价格一般以对手单价格为准，这种做法的目的是为了保护take单；
* 时间优先：相同价格下，优先进行盘口的订单会优先被成交；

虽然我们在这里的概念会比较多，但是算法相对来说是比较简单的，不用太担心。同时必须强调的是：

1. 撮合是一个通用的算法，无论是对区块链还是股票其实算法逻辑都是一样的；
2. 撮合通常都是单线程的，基于内存的算法速度非常快，不用太担心速度问题；
3. 始终记住一点，基于内存的计算速度是非常快的。针对一个symbol没有所谓的分布式撮合或者基于mq直接做撮合的做法。

---

## 1、订单数据结构（简称Order）

| id | 交易类型 | 方向 | 价格|数量 |交易对|用户ID |
| ------------ | ------------ | ------------ |------------ | ------------ |------------ | ------------ |
|   1001 | limit | buy |1000 | 1 | BTCUSDT | 1 |
|   1002 | limit | buy |1000 | 1 | BTCUSDT | 1 |
|   1003 | limit | buy | 999 | 1 |BTCUSDT | 1 |
|   1004 | limit | buy | 998 | 1 |BTCUSDT | 1 |


## 2、订单薄数据结构(简称OrderBook)

一个订单薄包含买盘数据，和卖盘数据。同时注意上面我们讲过，撮合的基本规则是价格优先和时间优先。

* 买盘：谁出的价格高，自然有权利先购买——价格从大到小排序，结构为K-V，K是价格，V是list；
* 卖盘：谁出的价格低，自然有权利先出售——价格从小到大排序，结构为K-V，K是价格，V是list；



我们必须知道的是：

* 我出价10000USDT去购买BTC，只有在mark单挂单价格小于10000USDT的时候，才会以挂单价格成交，否则数据会进入订单薄；
* 我要价10001USDT去出售BTC，只有在mark单挂单价格大于10001USDT的时候，才会以挂单价格成交，否则数据会进入订单薄；

所以通常我们说的订单薄大概这个样子：

买盘数据（从大到小）：

| 价格     | 订单集合   |
| ------------ | ------------ |
|   10000 | [order[1],order[2]] |
|   9999 | [order[3],order[4]] |

卖盘数据（从小到大）：

| 价格     | 订单集合   |
| ------------ | ------------ |
|   10001 | [order[5],order[6]] |
|   10002 | [order[7],order[8]] |

---

## 3、基础算法(简称OrderBook)

OK，现在我们得到了Order和OrderBook的基础数据结构了，我们开始准备一些测试数据：

| id | 交易类型 | 方向 | 价格|数量 |交易对|用户ID |
| ------------ | ------------ | ------------ |------------ | ------------ |------------ | ------------ |
|   1001 | limit | buy |1000 | 1 | BTCUSDT | 1 |
|   1002 | limit | buy |1000 | 1 | BTCUSDT | 2 |
|   1003 | limit | buy | 999 | 1 |BTCUSDT | 3 |

那么我们来用例子推导一下撮合逻辑：

第一条数据、因为这是买单，所以我需要从卖盘的第一个档位开始取数据。首先我需要判断卖盘的价格是不是小于1000，如果是的话，我们进行撮合，如果不是话，我们id位1001的这条数据会进行盘口。现在我们什么都没有所以把这条数据放到盘口中，我们的盘口应该是这样子的：
  
  | 买盘价格     | 订单集合   |
| ------------ | ------------ |
|   1000 | [order[1001]] |
  
  | 卖盘价格     | 订单集合   |
| ------------ | ------------ |
|   | |
  
  
第二条数据、同上一条数据一样，此时卖盘数据为空，这条数据也会进入盘口。这里需要注意，因为1002的价格和1001一样的，所以我们把两个订单放在一个集合中，如下：
  
  | 买盘价格     | 订单集合   |
| ------------ | ------------ |
|   1000 | [order[1001],order[1002]] |
  
  | 卖盘价格     | 订单集合   |
| ------------ | ------------ |
|   | |
  
  
第三条数据、同一条数据一样，此时卖盘数据为空，这条数据也会进入盘口，如下：
  
  | 买盘价格     | 订单集合   |
| ------------ | ------------ |
|   1000 | [order[1001],order[1002]] |
|   999 | [order[1003]] |
  
  | 卖盘价格     | 订单集合   |
| ------------ | ------------ |
|   | |
  
  

现在我们知道数据是如何进入盘口的了，为了做一个方便我们测试的数据，我们还需要做一些sell卖出的测试数据：

| id | 交易类型 | 方向 | 价格|数量 |交易对|用户ID |
| ------------ | ------------ | ------------ |------------ | ------------ |------------ | ------------ |
|   1004 | limit | sell |1001 | 1 | BTCUSDT | 4 |
|   1005 | limit | sell |1001 | 1 | BTCUSDT | 5 |
|   1006 | limit | sell |1002 | 1 |BTCUSDT | 6 |

第一条数据、因为1004是卖出的数据，所以需要从买盘的第一个档位开始取数据，如买盘第一条数据大于这1004的要价，即1001USDT的话，我们再进入下一步，很显然买盘第一档位的价格是1000USDT，所以这条数据进入订单薄：
  
  | 买盘价格     | 订单集合   |
| ------------ | ------------ |
|   1000 | [order[1001],order[1002]] |
|   999 | [order[1003]] |
  
  | 卖盘价格     | 订单集合   |
| ------------ | ------------ |
| 1001  | [order[1004]] |
  
  
第二条数据、同理：
  
  | 买盘价格     | 订单集合   |
| ------------ | ------------ |
|   1000 | [order[1001],order[1002]] |
|   999 | [order[1003]] |
  
  | 卖盘价格     | 订单集合   |
| ------------ | ------------ |
| 1001  | [order[1004],order[1005]] |
  
  
第三条数据、同理（到此为止，我们得到了一份标准的盘口数据，后续的操作将基于这一份OrderBook进行计算）：
  
  | 买盘价格     | 订单集合   |
| ------------ | ------------ |
|   1000 | [order[1001],order[1002]] |
|   999 | [order[1003]] |
  
  | 卖盘价格     | 订单集合   |
| ------------ | ------------ |
| 1001  | [order[1004],order[1005]] |
| 1002  | [order[1006]] |
  
  

OK,如果我们现在得到了一份标准的OrderBook数据。需要再次强调：1、买盘从大到小；2、卖盘从小到大；

现在，假设又过来一个人，创建一个新的Order，如下：

| id | 交易类型 | 方向 | 价格|数量 |交易对|用户ID |
| ------------ | ------------ | ------------ |------------ | ------------ |------------ | ------------ |
|   1007 | limit | buy |1001 | 1 | BTCUSDT | 7 |

好，现在开始我们进入重点 👏 👏 👏 👏 **。

第一步、id为1007的这一条数据，它是一个买入的订单，所以我们可以去取卖盘的第一个档位的数据：
 
| 卖盘价格     | 订单集合   |
| ------------ | ------------ |
| 1001  | [order[1004],order[1005]] |

我们发现id为1007的这条数据，它的出价是1001USDT，而取出的卖盘第一个档位的价格也是1001，满足了：

    buy出价 >= sell售价

的基本原则，所以我们可以进入下一步。

第二步、取出卖盘第一个档位的数据集合，并进行迭代:

[order[1004],order[1005]]

那么最先取出的数据是order[1004]，到这里，我们拿到了已经可以进行撮合的两条数据，
即ID为1007和ID为1001的数据。

第三步、现在可以进行交易了：

| id | 交易类型 | 方向 | 价格|数量 |交易对|用户ID |
| ------------ | ------------ | ------------ |------------ | ------------ |------------ | ------------ |
|   1007 | limit | buy |1001 | 1 | BTCUSDT | 7 |
|   1004 | limit | sell |1001 | 1 | BTCUSDT | 4 |

那么交易的结果是：用户ID为7的数据和用户ID为4的数据，可以进行成交，又因为ID为1007的数据是take单，
所以取ID位1004的价格为成交价（试着考虑一下，如果1007是以1002买入三个会是什么逻辑？）。

到这里我们可以简单的描述：用户-7，以1001USDT的价格从用户-4的手中，买到了1个BTC，把这句话组成数据
发送给"清算服务（有机会再讲）"即可。

最后，判断order[1004]的数量 减去 order[1007]需要的数量，如果剩余数量==0，则删除卖盘第一个档位中order[1004]这条数据。

## 4、总结
  
回顾上面的算法，非常的简单，我们其实只做了两个事情：

* 构建了一个订单薄；
* 基于订单，完成了一笔订单；

当然我们还会有其他一些逻辑和概念，但是所有的一切都是从这里开始的。


## 5、测试用例说明

---


